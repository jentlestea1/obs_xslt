<?xml version="1.0" encoding="ISO-8859-1"?>
<Chapter>
    <Title> Real Time Issues </Title>
    <Author>
        <Name> A. Pasetti </Name>
        <Affiliation>
            <a HREF="http://www.pnp-software.com">P&amp;P Software</a>
        </Affiliation>
        <EMail> pasetti@pnp-software.com </EMail>
    </Author>
    <LastModified> 2003-12-05 </LastModified>
    <Introduction>
        <p>The OBS Framework is designed to separate the design and implementation of the real-time
            aspects of an application from other aspects. In particular, it does not enforce any
            specific real-time architecture but is instead designed to be <i>compatible</i> with
            several architectures. This choice is motivated by a belief that other tools outside the
            OBS Framework already provide, or are expected to provide, solutions to the definition
            and analysis of real-time aspects. Rather than trying to replicate the facilities
            provided by these tools, the OBS Framework aims at compatibility with them.
            Compatibility is achieved at <i>code level</i> and at<i>architectural level</i>.</p>
    </Introduction>
    <Section Title="Code Level Compatibility">
        <p>At code level, the OBS Framework components are implemented to make static analysis of
            execution times possible. More precisely, the component expose two types of
                methods:<i>initialization methods</i> and <i>operational methods</i>. The former are
            intended to be called only during the application initialization phase and before the
            real-time part of the application has been entered. The latter may be called at any
            time. All operations that are not compatible with static timing analysis are confined to
            the initialization methods. This in particular applies to dynamic memory allocation
            operations. In an application instantiated from the OBS Framework, all memory for the
            application components is allocated at initialization time.</p>
        <p>In some cases, there is a need to dynamically gain access to a new component. This is for
            instance the case for <a href="doxygen/html/classTelecommand.html">telecommand
            components</a> that must be configured when the telecommand is received. For these
            situations, the framework provides<i>dynamic component factories</i> that can provide
            unconfigured components from an internally managed pool of preallocated component
            instances. The dynamic factory components are tailored to the needs of a particular
            application and are therfore generated by a dedicated <a
                href="indexGeneratorMeta-Components.html" target="_parent">generator meta-component</a>.</p>
        <p>The architecture of the OBS Framework is heavily based on <a
                href="indexDesignPatterns.html" target="_parent">object-oriented design
            patterns</a>. Such design patterns sometimes introduce recursion. The depth of the
            recursion, however, can always be statically bounded which ensures compatibility with
            static timing analysis.</p>
    </Section>
    <Section Title="Architectural Level Compatibility">
        <p>In its default form, the OBS Framework is only compatible with a cyclical non-preemptive
            real-time architecture. The typical entry points for a scheduler are the
            <code>activate</code> methods that are exposed by the following components:</p>
        <ul>
            <li>
                <cls>CC_TelecommandManager</cls>
            </li>
            <li>
                <cls>CC_TelemetryManager</cls>
            </li>
            <li>
                <cls>CC_ManoeuvreManager</cls>
            </li>
            <li>
                <cls>CC_PunctualActionManager</cls>
            </li>
            <li>
                <cls>CC_FSM</cls>
            </li>
            <li>Concrete telecommand loaders derived from the abstract class <cls>TelecommandLoader</cls>
            </li>
        </ul>
        <p>However, it should be stressed that application designers are in principle free to use
            other methods offered by the framework components. For instance, in another typical
            case, they might choose to link to the scheduler the<code>execute</code> methods
            declared by punctual action components (components derived from the base abstract
            class<cls>PunctualAction</cls>).<p/> The OBS Framework does not implement any
            synchronization or concurrency mechanisms. All method calls are synchronous and
            non-blocking. Furthermore, all methods are intended to model actions that are executed
            in a very short period of time. Actions that are intended to extend over prolonged
            periods of time can be modelled using the manoeuvre mechanism (see the <a
                href="ManoeuvreManagement.html">manoeuvre management</a> design pattern).</p>
        <p>If it is desired to use real-time architectures other than a simple cyclical
            non-preemptive architecture, then the framework components must be modified to be
            endowed with synchronization mechanisms and with activation mechanisms. For this
            purpose, the OBS Framework will offer <a href="indexTransformerMeta-Components.html"
                target="_parent">transformer meta-components</a> that can automate this tailoring
            process. The meta-components will implement various synchronization and activation
            mechanisms (e.g. Java-like <code>synchronize</code>, Ada-like protected types, HRT-HOOD
            style cyclical and sporadic objects, etc). The implementation will make use of operating
            system primitives and the meta-components will therefore model the most commong
            operating systems for OBS applications.</p>
    </Section>
</Chapter>
