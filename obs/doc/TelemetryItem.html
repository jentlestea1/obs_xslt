<?xml version="1.0" encoding="utf-8"?><html><head><link rel="stylesheet" type="text/css" href="css/main.css"/><link rel="stylesheet" type="text/css" href="css/3col_leftNav.css"/></head><body><div id="header"><h1 id="siteName">OBS Framework </h1><div id="globalNav"><a href="Home.html">Home</a> | <a href="General.html">General</a> | <a href="Implementation.html">Implementation</a> | <a href="doxygen/html/index.html" target="_blank">C++ Code Documentation</a> | <a href="http://www.pnp-software.com/ObsFramework/ObsFramework_0_8_3.zip">Download</a> | <a href="indexDisclaimer.html">Disclaimer</a></div><h2 id="pageName">Implementation - Design Patterns</h2></div><div id="navbar"><div id="sectionLinks"><ul><li><a href="indexDomainDictionary.html">Domain Dictionary</a></li><li><a href="indexDesignPatterns.html">Design Patterns</a></li><li><a href="indexAbstractInterfaces.html">Abstract Interfaces</a></li><li><a href="indexConcreteComponents.html">Concrete Components</a></li><li><a href="indexGeneratorMeta-Components.html">Generator Meta-Components</a></li><li><a href="indexTransformerMeta-Components.html">Transformer Meta-Components</a></li><li><a href="indexRealTimeIssues.html">Real Time Issues</a></li><li><a href="indexImplementationIssues.html">Implementation Issues</a></li><li><a href="indexInstallationIssues.html">Installation Issues</a></li><li><a href="indexSourceCode.html">Source Code</a></li><li><a href="doxygen/html/index.html" target="_blank">C++ Code Documentation</a></li></ul></div></div><div id="subnavbar"><li><a href="DesignPatternTable.html">- CATALOGUE -</a></li><li><a href="Connection.html">Connection</a></li><li><a href="ControlBlock.html">Control Block</a></li><li><a href="Event.html">Event</a></li><li><a href="FDIRCheck.html">FDIR Check</a></li><li><a href="FSM.html">FSM</a></li><li><a href="Manager.html">Manager</a></li><li><a href="ManoeuvreManagement.html">Manoeuvre Management</a></li><li><a href="ModeManagement.html">Mode Management</a></li><li><a href="OperatingSystemInterface.html">Operating System Interface</a></li><li><a href="ParameterDatabase.html">Parameter Database</a></li><li><a href="PunctualAction.html">Punctual Action</a></li><li><a href="RecoveryAction.html">Recovery Action</a></li><li><a href="ReconfigurationManagement.html">Reconfiguration Management</a></li><li><a href="SharedData.html">Shared Data</a></li><li><a href="TelecommandManagement.html">Telecommand Management</a></li><li><a href="Telemeterable.html">Telemeterable</a></li><li><a href="TelemetryManagement.html">Telemetry Management</a></li><li><a href="TelemetryStream.html">Telemetry Stream</a></li><li><a href="TelemetryItem.html">Telemetry Item</a></li><li><a href="Trace.html">Trace</a></li><li><a href="VariableMonitoring.html">Variable Monitoring</a></li></div><div id="content"><p><H4>Telemetry Item
        Design Pattern
         </H4></p><p><H3><b>Intent</b></H3></p><p>

Decouple the collection of a set of Telemetry Items from the content of these Telemetry Items.

</p><p><H3><b>Based On</b></H3></p><p>

This is pattern is based on the principle of <i>abstract coupling</i>.

</p><p><H3><b>Motivation</b></H3></p><p>

<p>

Virtually all on-board systems generate telemetry data. The <a HREF="Telemeterable.html">telemeterable

design pattern</a> proposes a solution to the problem of telemetry collection that is suitable for the

case where telemetry is seen as made up of a set of telemetry images generated by the various objects

that make up the on-board software. In that case, the problem of telemetry management is the problem

of managing these telemeterable objects in an application-independent manner.

</p><p>

In some on-board applications (especially in those that have a low level of complexity), however, the

telemetry data are best conceptualized as a sequence of independent words where each word carries some

specific and self-contained information. In this case, the problem of telemetry management is the problem

of assembling and collecting the telemetry items in an application-independent manner.

The telemetry item design pattern addresses this second problem.

</p>

</p><H3><b>Dictionary Entries</b></H3><p>The following abstractions or domain-wide concepts are defined to support the
        implementation of this design pattern:</p><ul><li><i><a HREF="domainDictionaryTelemetryItem.html">Telemetry Item</a></i></li></ul><p><H3><b>Structure</b></H3></p><p>

<p>

This design pattern is built around an abstract interface to represent the telemetry item

abstraction. The <CODE>TelemetryItem</CODE> interface represents an object that is capable of collecting

and assembling the information that goes into an individual telemetry item. This interface defines two

key operations. Operation <CODE>update</CODE> directs the telemetry item to collect the telemetry

information for which it is responsible and to internally assemble it in a format suitable for inclusion

in the telemetry stream. Operation

<CODE>getItem</CODE> returns the telemetry information that was thus constructed. An additional operation

<CODE>isValid</CODE> is provided to ask the telemetry item component to verify whether the telemetry information

it stores is valid.

</p><p>

The <CODE>TelemetryItem</CODE> interface serves as a generic interface through which a client component can

control the telemetry data acquisition process in an application-independent manner. The client maintains

a list of <CODE>TelemetryItem</CODE> objects and, when it is activated, it goes through the list, asks each

object to update its telemetry item and acquires the telemetry item and writes it to the telemetry channel.

The list of <CODE>TelemetryItem</CODE> objects is set up as part of the configuration process during application

initialization.

</p>

</p><p><center><img src="../figures/gif/TelemetryItemDP.gif"/></center></p><H3><b>Participants</b></H3><ul><li><CODE>Client</CODE>:  <Role>The component that is responsible for collecting and forwarding the telemetry data.</Role></li><li><CODE>TelemetryItem</CODE>:  <Role>The abstract interface that characterizes a component that can collect and format a single telemetry item.

</Role></li><li><CODE>ConcreteTmComponent</CODE>:  <Role>Component implementing interface <CODE>TelemetryItem</CODE> that represents a specific and concrete

component that provides a single telemetry item.</Role></li></ul><p><H3><b>Collaborations</b></H3></p><p>

The typical operational scenario for this design pattern is:

<ul>

<li>a client component is configured with a list of telemetry items components and, when it is activated, it

goes through the list and retrieves the telemetry items one by one and uses them to assemble the telemetry frame.

</li>

</ul>

</p><H3><b>Consequences</b></H3><ul><li>

Clients are decoupled from the format and content of the telemetry items: they only see components of

abstract <CODE>TelemetryItem</CODE> type. Changing the content or layout of single items has no impact

on the component that processes the telemetry data.

</li><li>

It is necessary to create a concrete class for each telemetry item. This may lead to a proliferation of classes.

</li></ul><p><H3><b>Applicability</b></H3></p><p>

This design pattern is useful when:

<ul>

<li>the telemetry data are best conceptualized as a sequence of independent bytes and there is a need to

decouple their management from their content and layout.

</li>

</ul>

</p><H3><b>Implementation Issues</b></H3><p>

How is a "telemetry item" to be represented in practice? In many cases it could be a primitive type - an

integer, a short integer or a byte - which is returned by method <CODE>getItem</CODE>. However, it could

also be an instance of a complex type in which case a means must be provided to serialize it to allow its

being written to the telemetry channel (that is often byte-oriented). If this complex type becomes very

elaborate, then this pattern becomes identical to the <a HREF="Telemeterable.html">telemeterable pattern</a>.

</p><H3><b>OBS Framework Mapping</b></H3><p>The implementation of this design pattern in the OBS Framework is supported by
        the following classes:</p><ul><li><i>TelemetryItem</i>abstract interface --&gt; <CODE><a href="doxygen/html/classTelemetryPacket.html">TelemetryPacket</a></CODE>, <CODE><a href="doxygen/html/classStructuredTelemetryPacket.html">StructuredTelemetryPacket</a></CODE>, <CODE><a href="doxygen/html/classPUSTelemetryPacket.html">PUSTelemetryPacket</a></CODE></li></ul><a NAME="#SampleCode"><p><H3><b>Sample Code</b></H3></p></a><p>

<p>

Consider a simple application where a telemetry frame consists of four words. Each word represents a telemetry item. 

This application would need to

define four concrete classes implementing the <CODE>TelemetryItem</CODE> interface. Their structure could be as follows:

<PRE>
    class Word_1: TelemetryItem {

        unsigned short tmWord;

        void update() {

        . . .  // acquire data that go into TM Word 1 and store them
        . . .  // in tmWord according to specified layout

        }

        short getItem() {
            return tmWord;
        }


        bool isValid() {
            return true;  // no validitiy check is performed
        }

    }</PRE>



The above implementation assumes that a telemetry item consists of an unsigned 16-bits integer and that no validity

check is performed upon it.

</p>

</p><p><H3><b>Remarks</b></H3></p><p>

None

</p><p><H3><b>Author</b></H3></p><p>

A. Pasetti (<a HREF="http://www.pnp-software.com">P&amp;P Software</a>)

</p><p><H3><b>Last Modified</b></H3></p><p>

2003-06-20

</p></div><div id="siteInfo"><a href="mailto:pasetti@control.ee.ethz.ch, cechti@control.ee.ethz.ch">Contact Us</a> | The OBS Framework Project</div></body></html>