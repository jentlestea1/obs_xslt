
//
// Copyright 2004 P&P Software GmbH - All Rights Reserved
//
// CC_ManoeuvreFactory.h
//
// This file was automatically generated by an XSL program
//

#ifndef CC_ManoeuvreFactoryH
#define CC_ManoeuvreFactoryH

#include "../GeneralInclude/ForwardDeclarations.h"
#include "../GeneralInclude/BasicTypes.h"
#include "../Base/CC_RootObject.h"   
#include "../Manoeuvre/DC_DummyConfigurableManoeuvre.h"  
#include "../Manoeuvre/DC_DummyManoeuvre.h"  
#include "../Manoeuvre/DC_TestPUSConfigurableManoeuvre.h"  

/**
 * Dynamic factory for components of type: <code>Manoeuvre</code>.
 * A <i>dynamic factory</i> is a component that manages a pool of instances of
 * components of a certain type. Clients of the factory can require one of these
 * instances at run-time. After the factory hands over a component instance to its
 * client, the instance is marked as "in use" and cannot be given to any other
 * clients. When the requesting client has finished using the instance, it should release
 * it by marking it as "no longer in use". This will allow the factory to make it
 * available to other clients that request it. The "in use" status of the component
 * instances is controlled through method <code>setInUse</code> declared on
 * the component instances.
 * <p>
 * A dynamic factory is configured in two steps. The first step is performed
 * by the factory constructor when the internal data structures to hold the component
 * instances are created. The second step is performed during application initialization
 * when the component instances are loaded in the factory. Reconfiguration at run time
 * during normal application operation is not allowed.
 * <p>
 * Dynamic factories are implemented as singletons. They can exist in one single instance
 * that can be accessed through the <code>getInstance</code> method.
 * The one single instance of the class is created the first time that method
 * getInstance is called. In order to avoid possible disruptions of
 * real-time behaviour, applications should ensure that this method has been called
 * at least once before the application enters its operational phase.
 * <p>
 * This factory manages the following component instances:<ul>  
 * <li>Number of instances of type <code>DC_DummyConfigurableManoeuvre</code>: 1</li>    
 * <li>Number of instances of type <code>DC_DummyManoeuvre</code>: 1</li>    
 * <li>Number of instances of type <code>DC_TestPUSConfigurableManoeuvre</code>: 1</li>    
 * </ul>
 * The code for this class was automatically generated by an XSL program processing
 * the XML-based application model.    
 * @ingroup Manoeuvre
 * @see Manoeuvre
 * @author Automatically Generated Class
 * @version 1.0
 */
class CC_ManoeuvreFactory : public CC_RootObject {

  private:
    static CC_ManoeuvreFactory* pInstance;     
    unsigned int sizeDummyConfigurableManoeuvre;
    DC_DummyConfigurableManoeuvre** poolDummyConfigurableManoeuvre;
      
    unsigned int sizeDummyManoeuvre;
    DC_DummyManoeuvre** poolDummyManoeuvre;
      
    unsigned int sizeTestPUSConfigurableManoeuvre;
    DC_TestPUSConfigurableManoeuvre** poolTestPUSConfigurableManoeuvre;
      

  protected:
    /**
     * Instantiate the factory component. The class identifier is set and
     * the internal data structures to hold the component instances managed
     * by the factory are created.
     * This constructor is defined to be protected because this is a singleton
     * class.
     */
    CC_ManoeuvreFactory(void);

  public:

    /**
     * Get the single instance of this singleton class. If the instance does not
     * yet exist, it is created.
     */
    static CC_ManoeuvreFactory* getInstance(void);

    /**
     * Check that all component instances required by the factory have been loaded.
     * @return true if the component is configured, false otherwise
     */
    virtual bool isObjectConfigured();

  
    /**
     * Load one instance of type <code>DC_DummyConfigurableManoeuvre</code> in the
     * factory. The component instances managed by the factory are internally stored in an
     * array. This method loads the i-th element of the array. The argument i should lie
     * in the interval [0,N-1] where N is the number of component instances of type
     * <code>DC_DummyConfigurableManoeuvre</code>. The value of N is defined by
     * the class constructor.
     * <p>
     * The "in use" status of a newly loaded component is initialized
     * to: "component is not in use".
     * <p>
     * This is an initialization method that should only be called during the application
     * configuration phase.
     * @param i the index in the internal array
     * @param pItem the component instance
     */
    void setManoeuvre(unsigned int i, DC_DummyConfigurableManoeuvre* pItem);

    /**
     * Return the number of component instances of type <code>DC_DummyConfigurableManoeuvre</code>
     * that are currently allocated. A component instance is allocated if its "in use" status is
     * equal to: "component is in use".
     * @return the number of allocated component instances
     */
    unsigned int getNumberDummyConfigurableManoeuvre(void);

    /**
     * Return the number of component instances of type <code>DC_DummyConfigurableManoeuvre</code>
     * that are in the factory. The value returned is the maximum number of component instances of
     * type <code>DC_DummyConfigurableManoeuvre</code> that can be allocated.
     * @return the total number of component instances in the factory of
     * type <code>DC_DummyConfigurableManoeuvre</code>
     */
    unsigned int getCapacityDummyConfigurableManoeuvre(void);

    /**
     * Allocate one instance of type <code>DC_DummyConfigurableManoeuvre</code>.
     * This method scans all the entries in the factory of type <code>DC_DummyConfigurableManoeuvre</code>
     * and returns the first one which is not in use. 
     * Before being returned to the caller,
     * the status of the component instance is changed to: "in use". A client that receives
     * a component instance through a call to this method, should release the instance when it
     * no longer needs it. This can be done by calling
     * method <code>setInUse(false)</code> on the component itself.
     * <p>
     * If no free component instances are found, then the method returns null. Note that no
     * event report is generated to record the failure to allocate a component instance. Event
     * reporting is the responsibility of the caller.      
     * @return the allocated component instance or null if no free instances were found
     */
    DC_DummyConfigurableManoeuvre* allocateDummyConfigurableManoeuvre();

    /**
     * Check whether a non-allocated component instance of type <code>DC_DummyConfigurableManoeuvre</code>
     * is available within the factory. If this method return true, then the corresponding
     * <code>allocate</code> method is guaranteed to return a non-null value.
     * The method parameters are used as in the corresponding <code>allocate</code> method.
     * @see #allocateDC_DummyConfigurableManoeuvre     
     * @return true if free instances of type DC_DummyConfigurableManoeuvre are available,
     * false otherwise
     */
    bool isFreeDummyConfigurableManoeuvre();

      
            
    /**
     * Load one instance of type <code>DC_DummyManoeuvre</code> in the
     * factory. The component instances managed by the factory are internally stored in an
     * array. This method loads the i-th element of the array. The argument i should lie
     * in the interval [0,N-1] where N is the number of component instances of type
     * <code>DC_DummyManoeuvre</code>. The value of N is defined by
     * the class constructor.
     * <p>
     * The "in use" status of a newly loaded component is initialized
     * to: "component is not in use".
     * <p>
     * This is an initialization method that should only be called during the application
     * configuration phase.
     * @param i the index in the internal array
     * @param pItem the component instance
     */
    void setManoeuvre(unsigned int i, DC_DummyManoeuvre* pItem);

    /**
     * Return the number of component instances of type <code>DC_DummyManoeuvre</code>
     * that are currently allocated. A component instance is allocated if its "in use" status is
     * equal to: "component is in use".
     * @return the number of allocated component instances
     */
    unsigned int getNumberDummyManoeuvre(void);

    /**
     * Return the number of component instances of type <code>DC_DummyManoeuvre</code>
     * that are in the factory. The value returned is the maximum number of component instances of
     * type <code>DC_DummyManoeuvre</code> that can be allocated.
     * @return the total number of component instances in the factory of
     * type <code>DC_DummyManoeuvre</code>
     */
    unsigned int getCapacityDummyManoeuvre(void);

    /**
     * Allocate one instance of type <code>DC_DummyManoeuvre</code>.
     * This method scans all the entries in the factory of type <code>DC_DummyManoeuvre</code>
     * and returns the first one which is not in use. 
     * Before being returned to the caller,
     * the status of the component instance is changed to: "in use". A client that receives
     * a component instance through a call to this method, should release the instance when it
     * no longer needs it. This can be done by calling
     * method <code>setInUse(false)</code> on the component itself.
     * <p>
     * If no free component instances are found, then the method returns null. Note that no
     * event report is generated to record the failure to allocate a component instance. Event
     * reporting is the responsibility of the caller.      
     * @return the allocated component instance or null if no free instances were found
     */
    DC_DummyManoeuvre* allocateDummyManoeuvre();

    /**
     * Check whether a non-allocated component instance of type <code>DC_DummyManoeuvre</code>
     * is available within the factory. If this method return true, then the corresponding
     * <code>allocate</code> method is guaranteed to return a non-null value.
     * The method parameters are used as in the corresponding <code>allocate</code> method.
     * @see #allocateDC_DummyManoeuvre     
     * @return true if free instances of type DC_DummyManoeuvre are available,
     * false otherwise
     */
    bool isFreeDummyManoeuvre();

      
            
    /**
     * Load one instance of type <code>DC_TestPUSConfigurableManoeuvre</code> in the
     * factory. The component instances managed by the factory are internally stored in an
     * array. This method loads the i-th element of the array. The argument i should lie
     * in the interval [0,N-1] where N is the number of component instances of type
     * <code>DC_TestPUSConfigurableManoeuvre</code>. The value of N is defined by
     * the class constructor.
     * <p>
     * The "in use" status of a newly loaded component is initialized
     * to: "component is not in use".
     * <p>
     * This is an initialization method that should only be called during the application
     * configuration phase.
     * @param i the index in the internal array
     * @param pItem the component instance
     */
    void setManoeuvre(unsigned int i, DC_TestPUSConfigurableManoeuvre* pItem);

    /**
     * Return the number of component instances of type <code>DC_TestPUSConfigurableManoeuvre</code>
     * that are currently allocated. A component instance is allocated if its "in use" status is
     * equal to: "component is in use".
     * @return the number of allocated component instances
     */
    unsigned int getNumberTestPUSConfigurableManoeuvre(void);

    /**
     * Return the number of component instances of type <code>DC_TestPUSConfigurableManoeuvre</code>
     * that are in the factory. The value returned is the maximum number of component instances of
     * type <code>DC_TestPUSConfigurableManoeuvre</code> that can be allocated.
     * @return the total number of component instances in the factory of
     * type <code>DC_TestPUSConfigurableManoeuvre</code>
     */
    unsigned int getCapacityTestPUSConfigurableManoeuvre(void);

    /**
     * Allocate one instance of type <code>DC_TestPUSConfigurableManoeuvre</code>.
     * This method scans all the entries in the factory of type <code>DC_TestPUSConfigurableManoeuvre</code>
     * and returns the first one which is not in use. 
     * Before being returned to the caller,
     * the status of the component instance is changed to: "in use". A client that receives
     * a component instance through a call to this method, should release the instance when it
     * no longer needs it. This can be done by calling
     * method <code>setInUse(false)</code> on the component itself.
     * <p>
     * If no free component instances are found, then the method returns null. Note that no
     * event report is generated to record the failure to allocate a component instance. Event
     * reporting is the responsibility of the caller.      
     * @return the allocated component instance or null if no free instances were found
     */
    DC_TestPUSConfigurableManoeuvre* allocateTestPUSConfigurableManoeuvre();

    /**
     * Check whether a non-allocated component instance of type <code>DC_TestPUSConfigurableManoeuvre</code>
     * is available within the factory. If this method return true, then the corresponding
     * <code>allocate</code> method is guaranteed to return a non-null value.
     * The method parameters are used as in the corresponding <code>allocate</code> method.
     * @see #allocateDC_TestPUSConfigurableManoeuvre     
     * @return true if free instances of type DC_TestPUSConfigurableManoeuvre are available,
     * false otherwise
     */
    bool isFreeTestPUSConfigurableManoeuvre();

      
            
};

#endif

