  
//
// Copyright 2003 P&P Software GmbH - All Rights Reserved
//
// TestCaseSampleR1Database_1.cpp
//
// This file was automatically generated by an XSL program
//

#include "../GeneralInclude/CompilerSwitches.h"
#include "../GeneralInclude/ClassId.h"
#include "../GeneralInclude/Constants.h"
#include "../Data/DC_SampleR1Database.h"
#include "TestCaseSampleR1Database_1.h"
#include "../Utilities/TestCaseWithEvtCheck.h"

#include <math.h>
#include <float.h>

TestCaseSampleR1Database_1::TestCaseSampleR1Database_1():
	TestCaseWithEvtCheck(ID_SAMPLER1DATABASE*10+1,"TestCaseSampleR1Database_1") {
		return;
}

void TestCaseSampleR1Database_1::runTestCase() {

   // Data structures to simulate the default and operational tables
   // (The size of the database is read from the Parameter Database
   // Descriptor file).
   unsigned int dbLength = 50;
   unsigned char* defaultTable = new unsigned char[dbLength];
   unsigned char* operationalTable = new unsigned char[dbLength];

   // Initialize the default database. Each parameter is given a
   // value equal to its parameter ID. The parameter ID is read from
   // the Parameter Database Descriptor File. Note that this
   // strategy will sometimes result in an attempt to assign to a
   // parameter a value that is inconsistent with its type (e.g. a
   // a parameter of type 'char' might have a parameter ID greater than
   // 256).
   unsigned char* uc;
   
   uc = (defaultTable+0);
   *(float*)uc = (float)1;
   uc = (defaultTable+8);
   *(float*)uc = (float)2;
   uc = (defaultTable+16);
   *(float*)uc = (float)3;
   uc = (defaultTable+24);
   *(float*)uc = (float)4;

   // Get current number of events in event repository
   unsigned int nEvt;
   nEvt = getNumberOfEvents();

   // Initialize the operational database to all zeros
   for (unsigned int i=0; i<dbLength; i++)
       operationalTable[i]=0;

   // Instantiate parameter database
   DC_SampleR1Database* pDB = new DC_SampleR1Database();

   // Variable to hold the maximum parId
   TD_DatabaseId maxParId;
   maxParId = 4;

   // Variable to hold the lowest illegal parId
   TD_DatabaseId illegalParId;
   illegalParId = 5;

   // Verify correctness of class ID
   if (pDB->getClassId() != ID_SAMPLER1DATABASE)
   {      setTestResult(TEST_FAILURE, "Wrong class ID");
            return;
    }

   // Check that database is not yet configured
   if ( pDB->isObjectConfigured() != NOT_CONFIGURED )
   {      setTestResult(TEST_FAILURE, "Incorrect configuration status at creation");
            return;
    }

   // Configure database
   pDB->setDefaultTable((char*)defaultTable);
   pDB->setOperationalTable((char*)operationalTable);
   pDB->reset();

   // Check that database is configured
   if ( pDB->isObjectConfigured() != CONFIGURED )
   {      setTestResult(TEST_FAILURE, "Incorrect configuration status after configuration was completed");
            return;
   }

   // Check the pointer getter methods
   
   if ((unsigned char*)pDB->getParameterPointerFloat(1)!=operationalTable+0)
   {      setTestResult(TEST_FAILURE, "Incorrect pointer value for parameter");
            return;
   }
   if ((unsigned char*)pDB->getParameterPointerFloat(2)!=operationalTable+8)
   {      setTestResult(TEST_FAILURE, "Incorrect pointer value for parameter");
            return;
   }
   if ((unsigned char*)pDB->getParameterPointerFloat(3)!=operationalTable+16)
   {      setTestResult(TEST_FAILURE, "Incorrect pointer value for parameter");
            return;
   }
   if ((unsigned char*)pDB->getParameterPointerFloat(4)!=operationalTable+24)
   {      setTestResult(TEST_FAILURE, "Incorrect pointer value for parameter");
            return;
   }

   // Check that non-real paramaters have the correct value
   

   // Check that real parameters have the correct value
   
   if (fabs(pDB->getParameterFloat(1)-1) > DBL_EPSILON)
   {      setTestResult(TEST_FAILURE, "Incorrect value for parameter");
            return;
   }
   if (fabs(pDB->getParameterFloat(2)-2) > DBL_EPSILON)
   {      setTestResult(TEST_FAILURE, "Incorrect value for parameter");
            return;
   }
   if (fabs(pDB->getParameterFloat(3)-3) > DBL_EPSILON)
   {      setTestResult(TEST_FAILURE, "Incorrect value for parameter");
            return;
   }
   if (fabs(pDB->getParameterFloat(4)-4) > DBL_EPSILON)
   {      setTestResult(TEST_FAILURE, "Incorrect value for parameter");
            return;
   }

   // Update the value of all parameters by setting it equal to their (parId+1)
   
   pDB->setParameter(1,(float)(1+1)); 
   pDB->setParameter(2,(float)(2+1)); 
   pDB->setParameter(3,(float)(3+1)); 
   pDB->setParameter(4,(float)(4+1)); 

   // Check that non-real paramaters have the correct value
   

   // Check that real paramaters have the correct value
   
   if (fabs(pDB->getParameterFloat(1)-(1+1)) > DBL_EPSILON)
   {      setTestResult(TEST_FAILURE, "Incorrect value for parameter 1");
            return;
   } 
   if (fabs(pDB->getParameterFloat(2)-(2+1)) > DBL_EPSILON)
   {      setTestResult(TEST_FAILURE, "Incorrect value for parameter 2");
            return;
   } 
   if (fabs(pDB->getParameterFloat(3)-(3+1)) > DBL_EPSILON)
   {      setTestResult(TEST_FAILURE, "Incorrect value for parameter 3");
            return;
   } 
   if (fabs(pDB->getParameterFloat(4)-(4+1)) > DBL_EPSILON)
   {      setTestResult(TEST_FAILURE, "Incorrect value for parameter 4");
            return;
   } 
	setTestResult(TEST_SUCCESS,"Test Successful");
	return;
}
