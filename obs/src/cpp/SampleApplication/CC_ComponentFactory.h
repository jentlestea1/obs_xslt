
//
// Copyright 2004 P&P Software GmbH - All Rights Reserved
//
// CC_ComponentFactory.h
//
// This file was automatically generated by an XSL program

#ifndef CC_ComponentFactoryH
#define CC_ComponentFactoryH

#include "../GeneralInclude/ForwardDeclarations.h"
#include "../GeneralInclude/BasicTypes.h"
#include "CC_ComponentFactory_inc.h"
#include "../Base/CC_RootObject.h"   
#include <assert.h>

/**
 * Application component factory.
 * This class creates and configures all the components required by the target application and makes
 * them available through getter methods. 
 * The components are created in the constructor and are then stored in an array.
 * A configuration method is provided that will configure all the created components.
 * The components can be accessed by clients exclusively through their pointers.
 * The pointers are returned by getter methods. There is one getter method for each
 * type of components managed by the component factory. The name of the getter
 * methods is of the form: <code>getXXX</code> where "XXX" is the type name
 * stripped of the initial prefix "DC_" or "CC_". The argument of the getter name is an
 * integer that represents the symbolic identifier of the component (it is an integer that, 
 * from the point of view of external components, acts 
 * as the component name). The symbolic identifiers of the components are stored in
 * the include file <code>CC_ComponentFactory_inc.h</code>. 
 * The getter methods return typed instances of the components. An assertion is used 
 * to verify that the getter method is consistent with the actual type of the component that
 * is being retrieved (i.e. to verify that a component of type "XXX" is retrieved with a call
 * to method <code>getXXX</code>). There are no other run-time checks
 * on the consistency of usage of the getter methods. This approach is justified because
 * the component factory should normally be used only during the application instantiation
 * phase and the type and order of the calls to the getter methods should be fixed. This
 * allows their correctness to be verified once and for all with assertions enabled.
 * <p>
 * This is a singleton class. Its only instance is accessed through its method 
 * <code>getInstance</code>.
 * <p>
 * This class is automatically generated by an XSL program that processes the XML-based
 * model of the target application.
 * <p>
 * This class manages a total of 101 components.
 * <p>
 * For reasons of efficiency, all getter methods are declared to be inline. 
 * <p>
 * Implementation note: this class maintains the component references in two distinct location.
 * For each component, a dedicated variable is delcared that holds the pointer to the component.
 * Additionally, an array <code>list</code> of pointers to the top-level type <code>CC_RootObject</code>
 * is declared that holds all the pointers to the components. The getter methods retrieve the components
 * from this array. The configuration methods instead use directly the component variables. 
 * Finally, an array of integers is provided that holds the values of the type identifiers for each
 * created component. 
 * @see CC_ComponentFactory_inc.h
 * @author Automatically Generated Class
 * @version 1.0
 */
class CC_ComponentFactory {

  private:
    static CC_ComponentFactory* pInstance;     
    DC_SampleFullDataPool* fullDataPool;
    DC_StuckDataProfile* sdMonProf_1;
    DC_OutOfRangeProfile* orMonProf_1;
    DC_SampleMonitoringProfile* sMonProf_1;
    DC_NullRecoveryAction* nRecAct_1;
    DC_OutOfRangeProfile* orMonProf_2;
    DC_SampleRecoveryAction* sRecAct_2;
    DC_NullRecoveryAction* nRecAct_2;
    DC_StuckDataProfile* sdMonProf_4;
    DC_OutOfRangeProfile* orMonProf_4;
    DC_NullRecoveryAction* nRecAct_4;
    DC_OutOfRangeProfile* orMonProf_5;
    DC_NullRecoveryAction* nRecAct_5;
    DC_StuckDataProfile* sdMonProf_7;
    DC_OutOfRangeProfile* orMonProf_7;
    DC_NullRecoveryAction* nRecAct_7;
    DC_OutOfRangeProfile* orMonProf_8;
    DC_NullRecoveryAction* nRecAct_8;
    DC_StuckDataProfile* sdMonProf_10;
    DC_OutOfRangeProfile* orMonProf_10;
    DC_NullRecoveryAction* nRecAct_10;
    DC_OutOfRangeProfile* orMonProf_11;
    DC_NullRecoveryAction* nRecAct_11;
    DC_SampleR2Database* parDB;
    CC_FSM* Nominal_FSM;
    DC_NestedFsmActivatorWithEndState* SBY_FsmState;
    DC_NestedFsmActivatorWithExitCheck* SAM_FsmState;
    DC_SCM_FsmState* SCM_FsmState;
    DC_OCM_FsmState* OCM_FsmState;
    DC_FromFsmEvent* SAM_to_OCM;
    DC_FromFsmEvent* OCM_to_SAM;
    DC_FromFsmEvent* SCM_to_SAM;
    DC_FromFsmEvent* SAM_to_SCM;
    DC_FromFsmEvent* SCM_to_OCM;
    DC_FromFsmEvent* OCM_to_SCM;
    CC_FSM* SBY_FSM;
    DC_SBY_PreSepFsmState* SBY_PreSeparation;
    DC_SBY_PostSepFsmState* SBY_PostSeparation;
    DC_DummyFsmState* END;
    CC_FSM* SAM_FSM;
    DC_UnstableFsmState* SAM_SunAcquisition;
    DC_DummyFsmState* SAM_SunPointing;
    CC_FSM* OCM_FSM;
    DC_UnstableFsmState* OCM_Slewing;
    DC_DummyFsmState* OCM_Pointing;
    DC_DummyFsmState* OCM_Thrusting;
    CC_FSM* SCM_FSM;
    DC_DummyFsmState* SCM_Slewing;
    DC_DummyFsmState* SCM_Pointing;
    DC_DummyFsmState* SCM_Scanning;
    CC_FSM* SM_FSM;
    DC_SM_PreSepFsmState* SM_PreSeparation;
    DC_UnstableFsmState* SM_PostSeparation;
    DC_UnstableFsmState* SM_SunAcquisition;
    DC_DummyFsmState* SM_SunPointing;
    DC_FromFsmEvent* SM_PreToPost;
    CC_FSM* FDIR_FSM;
    DC_AfsFsmState* AFS;
    DC_DummyFsmState* AFO;
    DC_FromFsmEvent* AFS_to_AFO;
    DC_FromFsmEvent* AFO_to_AFS;
    DC_ControlAction* contAction_1;
    DC_SampleControlBlock_1* contBlock_1;
    DC_ControlAction* contAction_2;
    DC_SampleControlBlock_2* contBlock_2;
    DC_ControlAction* contAction_3;
    DC_SampleControlBlock_3* contBlock_3;
    DC_ControlAction* contAction_4;
    DC_SampleControlBlock_4* contBlock_4;
    DC_DummyObsClock* obsClk;
    DC_PUSEventRepository* evtRep;
    DC_DummyTracer* tracer;
    CC_ManoeuvreManager* manMan;
    DC_DummyManoeuvre* man_1;
    DC_DummyConfigurableManoeuvre* man_2;
    DC_TestPUSConfigurableManoeuvre* man_3;
    CC_TelecommandManager* tcMan;
    DC_BasicPUSTcLoader* tcLoader;
    DC_DummyTelecommand* tc_1;
    DC_DummyTelecommand* tc_2;
    DC_DummyPUSTelecommand* tc_3;
    DC_PUSDefineDataReporting* tc_4;
    DC_PUSControlDataReporting* tc_5;
    DC_TestPUSTelecommand* tc_6;
    DC_TestPUSTelecommand* tc_7;
    DC_TestPUSTelecommand* tc_8;
    DC_PUSDumpMemoryAbsolute* tc_9;
    DC_PUSDumpMemoryOffset* tc_10;
    DC_PUSMemoryLoadAbsolute* tc_11;
    DC_PUSMemoryLoadAbsolute* tc_12;
    DC_PUSMemoryLoadOffset* tc_13;
    CC_TelemetryManager* tmMan;
    DC_BasicPUSTmStream* tmStream;
    DC_DummyPUSTelemetryPacket* tm_1;
    DC_DummyPUSTelemetryPacket* tm_2;
    DC_PUSTcVerificationPacket* tm_3;
    DC_PUSDataReportingPacket* tm_4;
    DC_PUSDataReportingPacket* tm_5;
    DC_PUSMemoryDumpAbsolute* tm_6;
    DC_PUSMemoryDumpOffset* tm_7;
    DC_PUSTelemetryModeManager* tmModeMan;
    
    CC_RootObject* list[101];
    int type[101+1];

  protected:
    /**
     * Instantiate the factory component. The components are created and their
     * pointers are stored in an internal array. A second array is initialized that holds
     * the type identifier of each component.
     * This constructor is defined to be protected because this is a singleton
     * class.
     */
    CC_ComponentFactory(void);

   /**
     * Configure the static part of the base class <code>CC_RootObject</code>. This method is called by method 
     * <code>configureApplication</code>
     */
     void configureRootObject(void);
   
    
    /**
     * Configure the component implementing the OBS Clock. This method is called by method 
     * <code>configureApplication</code>
     */
     void configureObsClock(void);
    
    /**
     * Configure the component implementing the event repository. This method is called by method 
     * <code>configureApplication</code>
     */
     void configureEventRepository (void);
    
    /**
     * Configure the components implementing the applications FSMs. This method configures the
     * FSM, their FsmStates and their FsmEvents. This method is called by method 
     * <code>configureApplication</code>
     */
     void configureFSM(void);
    
    /**
     * Configure the components implementing the control actions and control blocks. This method is called by method 
     * <code>configureApplication</code>
     */
     void configureControllers(void);
    
    /**
     * Configure the components implementing the application data pool. This method is called by method 
     * <code>configureApplication</code>
     */
     void configureDataPool(void);
    
    /**
     * Configure the components implementing the parameter database. This method is called by method 
     * <code>configureApplication</code>
     */
     void configureParameterDatabase(void);
    

    /**
     * Configure the functionality managers. This method is called by method 
     * <code>configureApplication</code>
     */
     void configureFunctionalityManagers(void);

  public:

    /**
     * Get the single instance of this singleton class. If the instance does not
     * yet exist, it is created.
     */
    static CC_ComponentFactory* getInstance(void);

    /**
     * Configure the application. All the components created in the constructor are configured
     * and linked together. The configuration code implements the configuration actions specified
     * in the application model. The application configuration process is broken up into a sequence
     * of steps. To each step a protected method in this class is associated. This method only
     * calls the step methods in sequence. The names of the step methods are formed as
     * follows: <code>configureXXX</code> where "XXX" is the name of a feature in
     * the application whose configuration is covered by the method.
     */
    void configureApplication(void);


   /**
    * Getter method for components of type <code>DC_ControlAction</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_ControlAction</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_ControlAction* getControlAction(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_ControlAction);
       return (DC_ControlAction*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_SampleControlBlock_1</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_SampleControlBlock_1</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_SampleControlBlock_1* getSampleControlBlock_1(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_SampleControlBlock_1);
       return (DC_SampleControlBlock_1*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_SampleControlBlock_2</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_SampleControlBlock_2</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_SampleControlBlock_2* getSampleControlBlock_2(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_SampleControlBlock_2);
       return (DC_SampleControlBlock_2*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_SampleControlBlock_3</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_SampleControlBlock_3</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_SampleControlBlock_3* getSampleControlBlock_3(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_SampleControlBlock_3);
       return (DC_SampleControlBlock_3*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_SampleControlBlock_4</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_SampleControlBlock_4</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_SampleControlBlock_4* getSampleControlBlock_4(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_SampleControlBlock_4);
       return (DC_SampleControlBlock_4*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_SampleFullDataPool</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_SampleFullDataPool</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_SampleFullDataPool* getSampleFullDataPool(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_SampleFullDataPool);
       return (DC_SampleFullDataPool*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_SampleR2Database</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_SampleR2Database</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_SampleR2Database* getSampleR2Database(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_SampleR2Database);
       return (DC_SampleR2Database*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_PUSEventRepository</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_PUSEventRepository</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_PUSEventRepository* getPUSEventRepository(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_PUSEventRepository);
       return (DC_PUSEventRepository*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_NullRecoveryAction</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_NullRecoveryAction</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_NullRecoveryAction* getNullRecoveryAction(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_NullRecoveryAction);
       return (DC_NullRecoveryAction*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_OutOfRangeProfile</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_OutOfRangeProfile</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_OutOfRangeProfile* getOutOfRangeProfile(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_OutOfRangeProfile);
       return (DC_OutOfRangeProfile*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_SampleMonitoringProfile</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_SampleMonitoringProfile</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_SampleMonitoringProfile* getSampleMonitoringProfile(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_SampleMonitoringProfile);
       return (DC_SampleMonitoringProfile*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_SampleRecoveryAction</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_SampleRecoveryAction</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_SampleRecoveryAction* getSampleRecoveryAction(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_SampleRecoveryAction);
       return (DC_SampleRecoveryAction*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_StuckDataProfile</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_StuckDataProfile</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_StuckDataProfile* getStuckDataProfile(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_StuckDataProfile);
       return (DC_StuckDataProfile*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>CC_FSM</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>CC_FSM</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline CC_FSM* getFSM(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_FSM);
       return (CC_FSM*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_AfsFsmState</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_AfsFsmState</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_AfsFsmState* getAfsFsmState(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_AfsFsmState);
       return (DC_AfsFsmState*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_DummyFsmState</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_DummyFsmState</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_DummyFsmState* getDummyFsmState(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_DummyFsmState);
       return (DC_DummyFsmState*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_FromFsmEvent</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_FromFsmEvent</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_FromFsmEvent* getFromFsmEvent(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_FromFsmEvent);
       return (DC_FromFsmEvent*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_NestedFsmActivatorWithEndState</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_NestedFsmActivatorWithEndState</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_NestedFsmActivatorWithEndState* getNestedFsmActivatorWithEndState(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_NestedFsmActivatorWithEndState);
       return (DC_NestedFsmActivatorWithEndState*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_NestedFsmActivatorWithExitCheck</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_NestedFsmActivatorWithExitCheck</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_NestedFsmActivatorWithExitCheck* getNestedFsmActivatorWithExitCheck(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_NestedFsmActivatorWithExitCheck);
       return (DC_NestedFsmActivatorWithExitCheck*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_OCM_FsmState</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_OCM_FsmState</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_OCM_FsmState* getOCM_FsmState(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_OCM_FsmState);
       return (DC_OCM_FsmState*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_SBY_PostSepFsmState</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_SBY_PostSepFsmState</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_SBY_PostSepFsmState* getSBY_PostSepFsmState(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_SBY_PostSepFsmState);
       return (DC_SBY_PostSepFsmState*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_SBY_PreSepFsmState</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_SBY_PreSepFsmState</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_SBY_PreSepFsmState* getSBY_PreSepFsmState(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_SBY_PreSepFsmState);
       return (DC_SBY_PreSepFsmState*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_SCM_FsmState</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_SCM_FsmState</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_SCM_FsmState* getSCM_FsmState(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_SCM_FsmState);
       return (DC_SCM_FsmState*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_SM_PreSepFsmState</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_SM_PreSepFsmState</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_SM_PreSepFsmState* getSM_PreSepFsmState(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_SM_PreSepFsmState);
       return (DC_SM_PreSepFsmState*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_UnstableFsmState</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_UnstableFsmState</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_UnstableFsmState* getUnstableFsmState(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_UnstableFsmState);
       return (DC_UnstableFsmState*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>CC_ManoeuvreManager</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>CC_ManoeuvreManager</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline CC_ManoeuvreManager* getManoeuvreManager(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_ManoeuvreManager);
       return (CC_ManoeuvreManager*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_DummyConfigurableManoeuvre</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_DummyConfigurableManoeuvre</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_DummyConfigurableManoeuvre* getDummyConfigurableManoeuvre(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_DummyConfigurableManoeuvre);
       return (DC_DummyConfigurableManoeuvre*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_DummyManoeuvre</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_DummyManoeuvre</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_DummyManoeuvre* getDummyManoeuvre(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_DummyManoeuvre);
       return (DC_DummyManoeuvre*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_TestPUSConfigurableManoeuvre</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_TestPUSConfigurableManoeuvre</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_TestPUSConfigurableManoeuvre* getTestPUSConfigurableManoeuvre(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_TestPUSConfigurableManoeuvre);
       return (DC_TestPUSConfigurableManoeuvre*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_DummyObsClock</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_DummyObsClock</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_DummyObsClock* getDummyObsClock(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_DummyObsClock);
       return (DC_DummyObsClock*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_DummyTracer</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_DummyTracer</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_DummyTracer* getDummyTracer(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_DummyTracer);
       return (DC_DummyTracer*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>CC_TelecommandManager</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>CC_TelecommandManager</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline CC_TelecommandManager* getTelecommandManager(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_TelecommandManager);
       return (CC_TelecommandManager*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_BasicPUSTcLoader</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_BasicPUSTcLoader</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_BasicPUSTcLoader* getBasicPUSTcLoader(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_BasicPUSTcLoader);
       return (DC_BasicPUSTcLoader*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_DummyPUSTelecommand</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_DummyPUSTelecommand</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_DummyPUSTelecommand* getDummyPUSTelecommand(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_DummyPUSTelecommand);
       return (DC_DummyPUSTelecommand*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_DummyTelecommand</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_DummyTelecommand</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_DummyTelecommand* getDummyTelecommand(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_DummyTelecommand);
       return (DC_DummyTelecommand*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_PUSControlDataReporting</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_PUSControlDataReporting</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_PUSControlDataReporting* getPUSControlDataReporting(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_PUSControlDataReporting);
       return (DC_PUSControlDataReporting*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_PUSDefineDataReporting</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_PUSDefineDataReporting</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_PUSDefineDataReporting* getPUSDefineDataReporting(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_PUSDefineDataReporting);
       return (DC_PUSDefineDataReporting*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_PUSDumpMemoryAbsolute</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_PUSDumpMemoryAbsolute</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_PUSDumpMemoryAbsolute* getPUSDumpMemoryAbsolute(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_PUSDumpMemoryAbsolute);
       return (DC_PUSDumpMemoryAbsolute*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_PUSDumpMemoryOffset</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_PUSDumpMemoryOffset</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_PUSDumpMemoryOffset* getPUSDumpMemoryOffset(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_PUSDumpMemoryOffset);
       return (DC_PUSDumpMemoryOffset*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_PUSMemoryLoadAbsolute</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_PUSMemoryLoadAbsolute</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_PUSMemoryLoadAbsolute* getPUSMemoryLoadAbsolute(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_PUSMemoryLoadAbsolute);
       return (DC_PUSMemoryLoadAbsolute*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_PUSMemoryLoadOffset</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_PUSMemoryLoadOffset</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_PUSMemoryLoadOffset* getPUSMemoryLoadOffset(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_PUSMemoryLoadOffset);
       return (DC_PUSMemoryLoadOffset*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_TestPUSTelecommand</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_TestPUSTelecommand</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_TestPUSTelecommand* getTestPUSTelecommand(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_TestPUSTelecommand);
       return (DC_TestPUSTelecommand*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>CC_TelemetryManager</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>CC_TelemetryManager</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline CC_TelemetryManager* getTelemetryManager(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_TelemetryManager);
       return (CC_TelemetryManager*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_BasicPUSTmStream</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_BasicPUSTmStream</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_BasicPUSTmStream* getBasicPUSTmStream(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_BasicPUSTmStream);
       return (DC_BasicPUSTmStream*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_DummyPUSTelemetryPacket</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_DummyPUSTelemetryPacket</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_DummyPUSTelemetryPacket* getDummyPUSTelemetryPacket(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_DummyPUSTelemetryPacket);
       return (DC_DummyPUSTelemetryPacket*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_PUSDataReportingPacket</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_PUSDataReportingPacket</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_PUSDataReportingPacket* getPUSDataReportingPacket(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_PUSDataReportingPacket);
       return (DC_PUSDataReportingPacket*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_PUSMemoryDumpAbsolute</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_PUSMemoryDumpAbsolute</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_PUSMemoryDumpAbsolute* getPUSMemoryDumpAbsolute(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_PUSMemoryDumpAbsolute);
       return (DC_PUSMemoryDumpAbsolute*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_PUSMemoryDumpOffset</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_PUSMemoryDumpOffset</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_PUSMemoryDumpOffset* getPUSMemoryDumpOffset(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_PUSMemoryDumpOffset);
       return (DC_PUSMemoryDumpOffset*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_PUSTcVerificationPacket</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_PUSTcVerificationPacket</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_PUSTcVerificationPacket* getPUSTcVerificationPacket(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_PUSTcVerificationPacket);
       return (DC_PUSTcVerificationPacket*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_PUSTelemetryModeManager</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_PUSTelemetryModeManager</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
   inline DC_PUSTelemetryModeManager* getPUSTelemetryModeManager(int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_PUSTelemetryModeManager);
       return (DC_PUSTelemetryModeManager*)list[compName];
   }
      
};

#endif

